<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Insect tree with placements</title>
  <style>
    /* Full viewport coverage */
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #root {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #fafafa;
      color: #333;
    }

    .taxonium-wrapper {
        width: 100%;
        height: 100%;
    }

    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #fafafa;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      transition: opacity 0.3s ease-out;
    }

    .loading-overlay.fade-out {
      opacity: 0;
      pointer-events: none;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #e0e0e0;
      border-top-color: #666;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      margin-top: 16px;
      color: #666;
      font-size: 14px;
    }

    .selected-nodes-panel {
      position: fixed;
      bottom: 200px;
      left: 16px;
      width: 280px;
      max-height: 300px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      font-size: 13px;
    }

    .selected-nodes-header {
      padding: 10px 12px;
      border-bottom: 1px solid #e0e0e0;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f5f5f5;
      border-radius: 8px 8px 0 0;
    }

    .selected-nodes-header button {
      background: none;
      border: none;
      color: #666;
      cursor: pointer;
      font-size: 12px;
      padding: 2px 6px;
    }

    .selected-nodes-header button:hover {
      color: #333;
      text-decoration: underline;
    }

    .selected-nodes-list {
      overflow-y: auto;
      flex: 1;
      padding: 0;
      margin: 0;
      list-style: none;
    }

    .selected-nodes-list:empty::after {
      content: "Click nodes on the tree to add them here";
      display: block;
      padding: 16px 12px;
      color: #999;
      font-style: italic;
      text-align: center;
    }

    .selected-node-item {
      padding: 8px 12px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .selected-node-item:last-child {
      border-bottom: none;
    }

    .selected-node-item:hover {
      background: #f9f9f9;
    }

    .selected-node-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .selected-node-remove {
      background: none;
      border: none;
      color: #999;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      padding: 0 4px;
    }

    .selected-node-remove:hover {
      color: #e53935;
    }

    .selected-nodes-actions {
      padding: 8px 12px;
      border-top: 1px solid #e0e0e0;
      background: #f5f5f5;
      border-radius: 0 0 8px 8px;
    }

    .copy-button {
      width: 100%;
      padding: 6px 12px;
      background: #1976d2;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .copy-button:hover {
      background: #1565c0;
    }

    .copy-button:active {
      background: #0d47a1;
    }

    .copy-button.copied {
      background: #43a047;
    }

    .selected-node-item-wrapper {
      border-bottom: 1px solid #eee;
    }

    .selected-node-item-wrapper:last-child {
      border-bottom: none;
    }

    .selected-node-metadata {
      padding: 6px 12px 10px 12px;
      background: #f9f9f9;
      font-size: 12px;
      color: #555;
    }

    .selected-node-metadata > div {
      margin-bottom: 4px;
    }

    .selected-node-metadata > div:last-child {
      margin-bottom: 0;
    }

    .selected-node-sequences {
      word-break: break-word;
      max-height: 150px;
      overflow-y: auto;
      font-size: 11px;
      line-height: 1.4;
    }

    .selected-node-sequences .sequence-item {
      margin-bottom: 2px;
    }
  </style>
</head>
<body>
  <div id="loading-overlay" class="loading-overlay">
    <div class="spinner"></div>
    <div class="loading-text">Loading tree...</div>
  </div>
  <div id="root"></div>

  <script type="module">
    import React from 'https://esm.sh/react@19';
    import { createRoot } from 'https://esm.sh/react-dom@19/client';
    import Taxonium from 'https://esm.sh/taxonium-component';

    const { createElement: h, useState, useEffect, useCallback } = React;

    // Selected Nodes Panel Component
    function SelectedNodesPanel({ nodes, onRemove, onClear }) {
      const [copied, setCopied] = useState(false);
      const [expanded, setExpanded] = useState({});

      const toggleExpand = (nodeId) => {
        setExpanded(prev => ({ ...prev, [nodeId]: !prev[nodeId] }));
      };

      const handleCopy = () => {
        const text = nodes.map(n => {
          let line = n.name;
          if (n.metadata) {
            if (n.metadata.placement_count !== undefined) line += `\tPlacements: ${n.metadata.placement_count}`;
            if (n.metadata.placement_bin !== undefined) line += `\tBin: ${n.metadata.placement_bin}`;
          }
          return line;
        }).join('\n');
        navigator.clipboard.writeText(text).then(() => {
          setCopied(true);
          setTimeout(() => setCopied(false), 2000);
        });
      };

      return h('div', { className: 'selected-nodes-panel' },
        h('div', { className: 'selected-nodes-header' },
          h('span', null, `Selected Nodes (${nodes.length})`),
          nodes.length > 0 && h('button', { onClick: onClear }, 'Clear all')
        ),
        h('ul', { className: 'selected-nodes-list' },
          nodes.map((node, index) =>
            h('li', { key: node.id || index, className: 'selected-node-item-wrapper' },
              h('div', { className: 'selected-node-item' },
                h('span', {
                  className: 'selected-node-name',
                  title: node.name,
                  onClick: () => toggleExpand(node.id),
                  style: { cursor: 'pointer' }
                }, node.name),
                h('button', {
                  className: 'selected-node-remove',
                  onClick: () => onRemove(node.id),
                  title: 'Remove'
                }, '\u00d7')
              ),
              expanded[node.id] && node.metadata && h('div', { className: 'selected-node-metadata' },
                node.metadata.placement_count !== undefined &&
                  h('div', null, `Placements: ${node.metadata.placement_count}`),
                node.metadata.placement_bin !== undefined &&
                  h('div', null, `Bin: ${node.metadata.placement_bin}`),
                node.metadata.top_sequences &&
                  h('div', { className: 'selected-node-sequences' },
                    h('div', null, 'Top sequences:'),
                    ...node.metadata.top_sequences.split(';').map((seq, i) =>
                      h('div', { key: i, className: 'sequence-item' }, seq.trim())
                    )
                  )
              )
            )
          )
        ),
        nodes.length > 0 && h('div', { className: 'selected-nodes-actions' },
          h('button', {
            className: `copy-button${copied ? ' copied' : ''}`,
            onClick: handleCopy
          }, copied ? 'Copied!' : 'Copy to clipboard')
        )
      );
    }

    function App() {
      const [sourceData, setSourceData] = useState(null);
      const [error, setError] = useState(null);
      const [query, setQuery] = useState({});
      const [selectedNodes, setSelectedNodes] = useState([]);

      // Handler to update query state (used by Taxonium for view/selection state)
      const updateQuery = (newQuery) => {
        setQuery(prev => ({ ...prev, ...newQuery }));
      };

      // Handler for when node details are loaded - adds to our list with full metadata
      const handleNodeDetailsLoaded = useCallback((nodeId, nodeDetails) => {
        if (nodeId === null || !nodeDetails) return;

        // Extract the node name from details - prefer meta_name from metadata
        const nodeName = nodeDetails.meta_name
          || nodeDetails.name
          || nodeDetails.label
          || `Node ${nodeId}`;

        // Extract metadata fields
        const metadata = {
          placement_count: nodeDetails.meta_placement_count,
          placement_bin: nodeDetails.meta_placement_bin,
          top_sequences: nodeDetails.meta_top_sequences,
        };

        setSelectedNodes(prev => {
          // Don't add duplicates
          if (prev.some(n => n.id === nodeId)) {
            return prev;
          }
          return [...prev, { id: nodeId, name: String(nodeName), metadata }];
        });
      }, []);

      // Handler to remove a node from the list
      const handleRemoveNode = useCallback((nodeId) => {
        setSelectedNodes(prev => prev.filter(n => n.id !== nodeId));
      }, []);

      // Handler to clear all nodes
      const handleClearNodes = useCallback(() => {
        setSelectedNodes([]);
      }, []);

      // Workaround: Enable "Display points for internal nodes" after component loads
      useEffect(() => {
        if (!sourceData) return;

        const enableInternalNodes = () => {
          // Find and click the settings button (gear icon) to open the modal
          const settingsButton = document.querySelector('button[aria-label="Settings"]')
            || document.querySelector('button svg[data-icon="cog"]')?.closest('button')
            || Array.from(document.querySelectorAll('button')).find(btn =>
                btn.querySelector('svg') && btn.textContent === '');

          if (!settingsButton) {
            console.log('Settings button not found, retrying...');
            return false;
          }

          settingsButton.click();

          // Wait for modal to open, then find the checkboxes
          setTimeout(() => {
            const labels = Array.from(document.querySelectorAll('label'));

            // Enable "Display points for internal nodes"
            const pointsLabel = labels.find(label =>
              label.textContent.includes('Display points for internal nodes')
            );
            const pointsCheckbox = pointsLabel?.querySelector('input[type="checkbox"]');
            if (pointsCheckbox && !pointsCheckbox.checked) {
              pointsCheckbox.click();
              console.log('Enabled: Display points for internal nodes');
            }

            // Enable "Display labels for internal nodes if present"
            const labelsLabel = labels.find(label =>
              label.textContent.includes('Display labels for internal nodes')
            );
            const labelsCheckbox = labelsLabel?.querySelector('input[type="checkbox"]');
            if (labelsCheckbox && !labelsCheckbox.checked) {
              labelsCheckbox.click();
              console.log('Enabled: Display labels for internal nodes if present');
            }

            // Close the modal by clicking the close button or backdrop
            setTimeout(() => {
              // Try clicking a close button (X)
              const closeButton = document.querySelector('[aria-label="Close"]')
                || document.querySelector('button svg[data-icon="times"]')?.closest('button')
                || document.querySelector('[role="dialog"] button');

              if (closeButton) {
                closeButton.click();
              } else {
                // Try clicking the backdrop/overlay
                const backdrop = document.querySelector('[role="dialog"]')?.parentElement;
                if (backdrop) {
                  backdrop.click();
                }
              }

              // Fade out the loading overlay after modal is closed
              setTimeout(() => {
                const overlay = document.getElementById('loading-overlay');
                if (overlay) {
                  overlay.classList.add('fade-out');
                  // Remove from DOM after transition completes
                  setTimeout(() => overlay.remove(), 300);
                }
              }, 100);
            }, 100);
          }, 300);

          return true;
        };

        // Retry until the settings button is available
        const timer = setInterval(() => {
          if (enableInternalNodes()) {
            clearInterval(timer);
          }
        }, 1000);

        // Stop trying after 10 seconds and remove overlay anyway
        const timeout = setTimeout(() => {
          clearInterval(timer);
          const overlay = document.getElementById('loading-overlay');
          if (overlay) {
            overlay.classList.add('fade-out');
            setTimeout(() => overlay.remove(), 300);
          }
        }, 10000);

        return () => {
          clearInterval(timer);
          clearTimeout(timeout);
        };
      }, [sourceData]);

      useEffect(() => {
        const loadData = async () => {
          try {
            // Fetch the Newick tree data and metadata in parallel
            const [nwkResponse, metadataResponse] = await Promise.all([
              fetch('tree.nwk'),
              fetch('metadata.tsv')
            ]);

            if (!nwkResponse.ok) {
              throw new Error(`Failed to load tree.nwk: ${nwkResponse.statusText}`);
            }
            const nwk = await nwkResponse.text();

            // Load metadata if available
            let metadata = null;
            let colorMapping = {};
            if (metadataResponse.ok) {
              const metadataText = await metadataResponse.text();
              metadata = {
                status: "loaded",
                filename: "metadata.tsv",
                filetype: "meta_tsv",
                data: metadataText,
                taxonColumn: "name",
              };

              // Parse metadata to find unique placement_bin values
              const lines = metadataText.trim().split('\n');
              const header = lines[0].split('\t');
              const binIndex = header.indexOf('placement_bin');

              if (binIndex !== -1) {
                const uniqueBins = [...new Set(
                  lines.slice(1).map(line => line.split('\t')[binIndex])
                )].filter(v => v !== '').sort((a, b) => Number(a) - Number(b));

                // Accessible Sunset palette from Bokeh (Paul Tol's scheme)
                const sunsetPalette = [
                  [54, 75, 154],   // #364B9A - deep blue
                  [74, 123, 183],  // #4A7BB7
                  [110, 166, 205], // #6EA6CD
                  [152, 202, 225], // #98CAE1
                  [194, 228, 239], // #C2E4EF
                  [234, 236, 204], // #EAECCC - pale yellow
                  [254, 218, 139], // #FEDA8B
                  [253, 179, 102], // #FDB366
                  [246, 126, 75],  // #F67E4B
                  [221, 61, 45],   // #DD3D2D
                  [165, 0, 38]     // #A50026 - deep red
                ];

                // Generate color from palette based on position
                const generateColor = (value, values) => {
                  if (value === '0' || value === 0) {
                    return [180, 180, 180]; // Grey for zero
                  }
                  const nonZeroValues = values.filter(v => v !== '0' && v !== 0);
                  const idx = nonZeroValues.indexOf(value);
                  const t = nonZeroValues.length > 1 ? idx / (nonZeroValues.length - 1) : 0;

                  // Use full Sunset palette (blue to red)
                  const paletteIdx = Math.min(
                    Math.floor(t * (sunsetPalette.length - 0.01)),
                    sunsetPalette.length - 1
                  );
                  return sunsetPalette[paletteIdx];
                };

                uniqueBins.forEach(bin => {
                  colorMapping[String(bin)] = generateColor(bin, uniqueBins);
                });

                console.log('Generated colorMapping:', colorMapping);
              }
            }

            // Construct the sourceData object with metadata
            const newSourceData = {
              status: "loaded",
              filename: "tree.nwk",
              filetype: "nwk",
              data: nwk,
              metadata: metadata,
              colorMapping: colorMapping,
            };

            setSourceData(newSourceData);

          } catch (err) {
            console.error("Error loading Taxonium data:", err);
            setError(err.message);
          }
        };

        loadData();
      }, []);

      if (error) {
        return h('div', null, `Error: ${error}`);
      }

      if (!sourceData) {
        return h('div', null, 'Loading Taxonium data...');
      }

      // Render the Taxonium component with documented props and selected nodes panel
      return h('div', { className: 'taxonium taxonium-wrapper' },
        h(Taxonium, {
          sourceData: sourceData,
          configDict: {
            defaultColorByField: "meta_placement_bin",
            colorMapping: sourceData.colorMapping || {},
            keys_to_display: [
              "meta_placement_count",
              "meta_placement_bin",
              "meta_top_sequences"
            ]
          },
          query: query,
          updateQuery: updateQuery,
          onNodeDetailsLoaded: handleNodeDetailsLoaded,
        }),
        h(SelectedNodesPanel, {
          nodes: selectedNodes,
          onRemove: handleRemoveNode,
          onClear: handleClearNodes,
        })
      );
    }

    const container = document.getElementById('root');
    const root = createRoot(container);
    root.render(h(App));
  </script>
</body>
</html>
